/**
 * SQL Generator Utility
 * Converts workspace schema to SQL DDL statements.
 */

import { HashMap } from "effect";
import { type Workspace, type Relation, type TableId } from "./model";

export const generateSQL = (workspace: Workspace): string => {
    // Convert HashMap to array for processing
    const relationsArray = Array.from(HashMap.values(workspace.relations));
    const tables = relationsArray.map(generateTableSQL);
    const foreignKeys = generateForeignKeySQL(workspace);

    return [
        "-- Database Schema Export",
        "-- Generated by Closure",
        "",
        ...tables,
        "",
        ...foreignKeys,
    ].join("\n");
};

const generateTableSQL = (relation: Relation): string => {
    const tableName = snakeCase(relation.name);

    // Column type inference (naive, defaults to TEXT)
    const columns = relation.attributes.map((attr) => {
        const colName = snakeCase(attr);
        const type = inferType(colName);
        return `    ${colName} ${type}`;
    });

    // Try to infer PK: looks for 'id' or 'table_id'
    const pk = relation.attributes.find(
        (a) => snakeCase(a) === "id" || snakeCase(a) === `${tableName}_id`
    );

    const constraints: string[] = [];
    if (pk) {
        constraints.push(`    PRIMARY KEY (${snakeCase(pk)})`);
    }

    const body = [...columns, ...constraints].join(",\n");

    return `CREATE TABLE ${tableName} (\n${body}\n);\n`;
};

const generateForeignKeySQL = (workspace: Workspace): string[] => {
    // Build IDâ†’Name lookup
    const idToName = new Map<TableId, string>();
    for (const rel of HashMap.values(workspace.relations)) {
        idToName.set(rel.id, rel.name);
    }

    const result: string[] = [];

    // Iterate over HashMap entries for foreign keys
    for (const fk of HashMap.values(workspace.foreignKeys)) {
        const fromName = idToName.get(fk.fromTableId);
        const toName = idToName.get(fk.toTableId);
        if (!fromName || !toName) continue;

        const fromTable = snakeCase(fromName);
        const toTable = snakeCase(toName);
        const fromCol = snakeCase(fk.fromAttribute);
        const toCol = snakeCase(fk.toAttribute);
        const constraintName = `fk_${fromTable}_${fromCol}`;

        result.push(
            `ALTER TABLE ${fromTable} ADD CONSTRAINT ${constraintName} FOREIGN KEY (${fromCol}) REFERENCES ${toTable} (${toCol});`
        );
    }

    return result;
};

// Helpers

const snakeCase = (str: string): string => {
    return str
        .replace(/([A-Z])/g, "_$1")
        .toLowerCase()
        .replace(/^_/, "")
        .replace(/\s+/g, "_");
};

const inferType = (colName: string): string => {
    if (colName.endsWith("_id") || colName === "id") return "INTEGER";
    if (colName.includes("date") || colName.includes("time")) return "TIMESTAMP";
    if (colName.includes("is_") || colName.includes("has_")) return "BOOLEAN";
    if (colName.includes("count") || colName.includes("num")) return "INTEGER";
    if (colName.includes("price") || colName.includes("cost")) return "DECIMAL(10,2)";
    return "TEXT";
};
